//! Local analysis bridge.
//!
//! Bridges the CLI's IR (built by unfault-core) with the analysis engine
//! (unfault-analysis). Replaces the old API call to `/api/v1/graph/analyze`.

use std::time::Instant;

use anyhow::{Context, Result};

use crate::output::{IrAnalyzeResponse, IrFinding, IrGraphStats};

/// Run analysis locally on a serialized IR.
///
/// This replaces the old `api_client.analyze_ir()` call. The flow is:
/// 1. Deserialize the IR JSON (from unfault-core format)
/// 2. Rebuild graph indexes
/// 3. Resolve profiles to rule IDs
/// 4. Run matching rules against the IR
/// 5. Convert findings to the CLI's display format
pub async fn analyze_ir_locally(ir_json: String, profiles: &[String]) -> Result<IrAnalyzeResponse> {
    let start = Instant::now();

    // Step 1: Deserialize IR (analysis crate's format is compatible via JSON)
    let mut ir: unfault_analysis::ir::IntermediateRepresentation =
        serde_json::from_str(&ir_json).context("Failed to deserialize IR for analysis")?;

    // Step 2: Rebuild indexes (needed after deserialization)
    ir.rebuild_indexes();

    let file_count = ir.semantics.len() as i32;

    // Step 3: Resolve profiles to rule IDs and run rules
    let profile_registry = unfault_analysis::profiles::ProfileRegistry::with_builtin_profiles();
    let rule_registry = unfault_analysis::rules::registry::RuleRegistry::with_builtin_rules();

    let rule_ids: Vec<String> = if profiles.is_empty() {
        // No profiles specified: run all rules
        rule_registry
            .all()
            .iter()
            .map(|r| r.id().to_string())
            .collect()
    } else {
        // Resolve profile IDs to rule IDs
        let resolved = unfault_analysis::ir::resolve_profile_rules(&profile_registry, profiles);
        if resolved.is_empty() {
            // Fallback: if no profiles matched, run all rules
            rule_registry
                .all()
                .iter()
                .map(|r| r.id().to_string())
                .collect()
        } else {
            resolved
        }
    };

    // Step 4: Run rules
    let findings =
        unfault_analysis::ir::analyze_ir_with_rules(&ir, &rule_registry, &rule_ids).await;

    let elapsed_ms = start.elapsed().as_millis() as i64;

    // Step 5: Convert RuleFindings to IrFindings
    let ir_findings: Vec<IrFinding> = findings
        .into_iter()
        .map(|f| {
            // Serialize the patch to JSON if present
            let patch_json = f.patch.as_ref().and_then(|p| serde_json::to_string(p).ok());

            IrFinding {
                rule_id: f.rule_id,
                title: f.title,
                description: f.description.unwrap_or_default(),
                severity: format!("{:?}", f.severity),
                dimension: format!("{:?}", f.dimension),
                file_path: f.file_path,
                line: f.line.unwrap_or(0),
                column: f.column.unwrap_or(0),
                end_line: f.end_line,
                end_column: f.end_column,
                message: String::new(),
                patch_json,
                fix_preview: f.fix_preview,
                patch: None, // Diff is generated by patch application, not here
                byte_start: f.byte_range.map(|(s, _)| s),
                byte_end: f.byte_range.map(|(_, e)| e),
            }
        })
        .collect();

    // Build graph stats from the IR
    let total_nodes = ir.graph.graph.node_count() as i32;
    let total_edges = ir.graph.graph.edge_count() as i32;
    let graph_stats = Some(IrGraphStats {
        file_count: ir.graph.file_nodes.len() as i32,
        function_count: ir.graph.function_nodes.len() as i32,
        class_count: ir.graph.class_nodes.len() as i32,
        external_module_count: ir.graph.external_modules.len() as i32,
        import_edge_count: 0,
        contains_edge_count: 0,
        uses_library_edge_count: 0,
        total_nodes,
        total_edges,
    });

    Ok(IrAnalyzeResponse {
        findings: ir_findings,
        file_count,
        elapsed_ms,
        graph_stats,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_analyze_empty_ir() {
        // Build a minimal valid IR JSON
        let ir_json = serde_json::json!({
            "semantics": [],
            "graph": {
                "graph": {
                    "nodes": [],
                    "node_holes": [],
                    "edge_property": "directed",
                    "edges": []
                }
            }
        });

        let result = analyze_ir_locally(ir_json.to_string(), &[]).await;
        assert!(result.is_ok());
        let response = result.unwrap();
        assert_eq!(response.file_count, 0);
        assert!(response.findings.is_empty());
    }
}
